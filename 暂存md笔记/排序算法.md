![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/4bcb1ed8-d56e-465e-b720-1d0c3b6903c5.png)

# 一、基本概念 

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/10327ca7-769e-4f9c-ba95-f7d1970edcf5.jpg)

# 二、插入排序

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/11e756ce-826e-4d4f-aec9-f7d62e4f86ac.png)

## 1、直接插入排序

### （1）直接插入排序基本思想

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/f915a020-dbcc-415d-992a-392225295549.png)

### （2）直接插入排序举例

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/021b1ca7-463a-460f-95a9-592e155d6461.jpg)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/(直接)插入排序.gif)

### （3）直接插入排序算法

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/35bb272b-0ca6-4f64-b7f2-a33c46a2a03d.png)

#### ① 整型数组版—不考虑稳定性

```java
package com.atguigu.array.sort;

/**
 * 直接插入排序
 * 
 * @author shkstart 2018-12-17
 */
public class InsertSort {
    public static void insertSort(int[] data) {
        System.out.println("开始排序");
        int arrayLength = data.length;
        for (int i = 1; i < arrayLength; i++) {
            int temp = data[i];
            if (data[i] - data[i - 1] < 0) {
                int j = i - 1;
                for (; j >= 0 && data[j] - temp > 0; j--) {
                    data[j + 1] = data[j];
                }
                data[j + 1] = temp;
            }
            System.out.println(java.util.Arrays.toString(data));
        }

    }

    public static void main(String[] args) {
        int[] data = { 9, -16, 21, 23, -30, -49, 21, 30, 30 };
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        insertSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```



#### ② 对象数组版—考虑稳定性

```java
package com.atguigu.array.sort2;

public class DataWrap implements Comparable<DataWrap>{
    int data;
    String flag;
    public DataWrap(int data,String flag){
        this.data = data;
        this.flag = flag;
    }
    public String toString(){
        return data + flag;
    }
    //根据data实例变量来决定两个dataWrap的大小
    @Override
    public int compareTo(DataWrap dw) {
        return this.data > dw.data? 1 : (this.data == dw.data? 0 : -1);
    }
    
}

```

```java
package com.atguigu.array.sort2;

/**
 * 直接插入排序
 * @author shkstart
 * 2018-12-17
 */
public class InsertSort {
    public static void insertSort(DataWrap[] data){
        System.out.println("开始排序");
        int arrayLength = data.length;
        for(int i = 1;i < arrayLength;i++){
            DataWrap temp = data[i];
            if(data[i].compareTo(data[i-1]) < 0){
                int j = i -1;
                for(;j >= 0 && data[j].compareTo(temp) > 0;j--){
                    data[j +1] = data[j];
                }
                data[j + 1] = temp;
            }
            System.out.println(java.util.Arrays.toString(data));
        }
        
    }
    public static void main(String[] args) {
        DataWrap[] data = { new DataWrap(9, ""), new DataWrap(-16, ""),
                new DataWrap(21, "*"), new DataWrap(23, ""),
                new DataWrap(-30, ""), new DataWrap(-49, ""),
                new DataWrap(21, ""), new DataWrap(30, "*"),
                new DataWrap(30, "")};
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        insertSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```

### （4）直接插入排序的效率分析

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/6d24f701-d496-4185-9174-982d92ffdd6d.png)

## 2、 希尔排序(缩小增量排序)

### （1）希尔排序的基本思想

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/07c06ff7-74cf-4c4f-9857-f8dba83f7b1e.png)

### （2）希尔排序举例

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/7cf21b1c-3d48-49cc-b54f-dc8243c03b9c.jpg)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/希尔排序.gif)

### （3）希尔排序算法

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/c46e42c8-04bd-404d-a1bf-63d377b1d56a.jpg)

#### ① 整型数组版—不考虑稳定性

```java
package com.atguigu.array.sort;
/**
 * Shell排序
 * @author shkstart
 * 2018-12-17
 */

public class ShellSort {
    public static void ShellSort(int[] data) {
        System.out.println("开始排序");
        int arrayLength = data.length;

        int h = 1;
        while (h <= arrayLength / 3) {
            h = h * 3 + 1;
        }
        while (h > 0) {
            System.out.println("===h的值：" + h + "===");
            for (int i = h; i < arrayLength; i++) {
                int temp = data[i];
                if (data[i] - data[i - h] < 0) {
                    int j = i - h;
                    for (; j >= 0 && data[j] - temp > 0; j -= h) {
                        data[j + h] = data[j];
                    }
                    data[j + h] = temp;
                }
                System.out.println(java.util.Arrays.toString(data));
            }
            h = (h - 1) / 3;
        }
    }

    public static void main(String[] args) {
        int[] data = { 9, -16, 21, 23, -30, -49, 21, 30, 30 };
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        ShellSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```

#### ② 对象数组版—考虑稳定性

```java
package com.atguigu.array.sort2;
/**
 * Shell排序
 * @author shkstart
 * 2018-12-17
 */

public class ShellSort {
    public static void ShellSort(DataWrap[] data) {
        System.out.println("开始排序");
        int arrayLength = data.length;

        int h = 1;
        while (h <= arrayLength / 3) {
            h = h * 3 + 1;
        }
        while (h > 0) {
            System.out.println("===h的值：" + h + "===");
            for (int i = h; i < arrayLength; i++) {
                DataWrap temp = data[i];
                if (data[i].compareTo(data[i - h]) < 0) {
                    int j = i - h;
                    for (; j >= 0 && data[j].compareTo(temp) > 0; j -= h) {
                        data[j + h] = data[j];
                    }
                    data[j + h] = temp;
                }
                System.out.println(java.util.Arrays.toString(data));
            }
            h = (h - 1) / 3;
        }
    }

    public static void main(String[] args) {
        DataWrap[] data = { 
                new DataWrap(9, ""), new DataWrap(-16, ""),
                new DataWrap(21, "*"), new DataWrap(23, ""),
                new DataWrap(-30, ""), new DataWrap(-49, ""),
                new DataWrap(21, ""), new DataWrap(30, "*"),
                new DataWrap(30, "")};
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        ShellSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```



### （4）希尔排序的效率分析

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/cfadf96d-07f2-42c0-9af8-448f88654653.png)

## 3、折半插入排序

### （1）整型数组版—不考虑稳定性

```java
package com.atguigu.array.sort;

/**
 * 折半插入排序
 * 
 * @author shkstart 2018-12-17
 */

public class BinaryInsertSort {
    public static void binaryInsertSort(int[] data) {
        System.out.println("开始排序");
        int arrayLength = data.length;
        for (int i = 1; i < arrayLength; i++) {
            int temp = data[i];
            int low = 0;
            int high = i - 1;
            while (low <= high) {
                int mid = (low + high) / 2;
                if (temp > data[mid]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
            for (int j = i; j > low; j--) {
                data[j] = data[j - 1];
            }
            data[low] = temp;
            System.out.println(java.util.Arrays.toString(data));
        }

    }

    public static void main(String[] args) {
        int[] data = { 9, -16, 21, 23, -30, -49, 21, 30, 30 };
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        binaryInsertSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```



### （2）对象数组版—考虑稳定性

```java
package com.atguigu.array.sort2;
/**
 * 折半插入排序
 * @author shkstart
 * 2018-12-17
 */

public class BinaryInsertSort {
    public static void binaryInsertSort(DataWrap[] data) {
        System.out.println("开始排序");
        int arrayLength = data.length;
        for (int i = 1; i < arrayLength; i++) {
            DataWrap temp = data[i];
            int low = 0;
            int high = i - 1;
            while (low <= high) {
                int mid = (low + high) / 2;
                if (temp.compareTo(data[mid]) > 0) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
            for (int j = i; j > low; j--) {
                data[j] = data[j - 1];
            }
            data[low] = temp;
            System.out.println(java.util.Arrays.toString(data));
        }

    }

    public static void main(String[] args) {
        DataWrap[] data = { new DataWrap(9, ""), new DataWrap(-16, ""),
                new DataWrap(21, "*"), new DataWrap(23, ""),
                new DataWrap(-30, ""), new DataWrap(-49, ""),
                new DataWrap(21, ""), new DataWrap(30, "*"),
                new DataWrap(30, "")};
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        binaryInsertSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```







# 三、交换排序

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/8c77518f-7bd4-4525-af28-bedb22a6328c.png)

## 1、冒泡排序

### （1）冒泡排序基本思想

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/121b0a62-4e58-4922-a828-c7fe18d33a94.png)

### （2）冒泡排序举例

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/60e68f07-5c38-4a04-bd7f-fd24f9e357c3.jpg)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/冒泡排序.gif)

### （3）冒泡排序算法

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/f3f203d9-9d39-470c-a398-0508ba37bd7c.png)

#### ① 整型数组版—不考虑稳定性

```java
package com.atguigu.array.sort;

/**
 * 冒泡排序 
 * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
 * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 
 * 针对所有的元素重复以上的步骤，除了最后一个。
 * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较
 * 
 * @author shkstart 2018-12-17
 */
public class BubbleSort {
    
    public static void bubbleSort(int[] data) {
        System.out.println("开始排序");
        int arrayLength = data.length;
        for (int i = 0; i < arrayLength - 1; i++) {
            for (int j = 0; j < arrayLength - 1 - i; j++) {
                if (data[j] > data[j + 1]) {
                    int temp = data[j + 1];
                    data[j + 1] = data[j];
                    data[j] = temp;
                }
            }
            System.out.println(java.util.Arrays.toString(data));
        }
    }
    //优化1
    public static void bubbleSort1(int[] data) {
        System.out.println("开始排序");
        int arrayLength = data.length;
        for (int i = 0; i < arrayLength - 1; i++) {
            boolean flag = false;
            for (int j = 0; j < arrayLength - 1 - i; j++) {
                if (data[j] > data[j + 1]) {
                    int temp = data[j + 1];
                    data[j + 1] = data[j];
                    data[j] = temp;
                    flag = true;
                }
            }
            System.out.println(java.util.Arrays.toString(data));
            if (!flag)
                break;
        }
    }

    public static void main(String[] args) {
        int[] data = { 9, -16, 21, 23, -30, -49, 21, 30, 30 };
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        bubbleSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```



#### ② 对象数组版—考虑稳定性

```java
package com.atguigu.array.sort2;

/**
 * 冒泡排序
 * @author shkstart
 * 2018-12-17
 */
public class BubbleSort {
    public static void bubbleSort(DataWrap[] data) {
        System.out.println("开始排序");
        int arrayLength = data.length;
        for (int i = 0; i < arrayLength - 1; i++) {
            boolean flag = false;
            for (int j = 0; j < arrayLength - 1 - i; j++) {
                if (data[j].compareTo(data[j + 1]) > 0) {
                    DataWrap temp = data[j + 1];
                    data[j + 1] = data[j];
                    data[j] = temp;
                    flag = true;
                }
            }
            System.out.println(java.util.Arrays.toString(data));
            if (!flag)
                break;
        }
    }

    public static void main(String[] args) {
        DataWrap[] data = { new DataWrap(9, ""), new DataWrap(-16, ""),
                new DataWrap(21, "*"), new DataWrap(23, ""),
                new DataWrap(-30, ""), new DataWrap(-49, ""),
                new DataWrap(21, ""), new DataWrap(30, "*"),
                new DataWrap(30, "")};
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        bubbleSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```



### （4）冒泡排序的效率分析

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/1c8255e8-81ff-40fa-b276-eb388bf960ed.png)

## 2、快速排序

### （1）快速排序基本思想

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/e1ba8352-bc54-402b-a042-8baedf108b90.jpg)

### （2）快速排序举例

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/bda12eed-b058-4066-9063-d16efa22a9e7.png)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/a4b3e721-b495-48c5-aabd-45e2ecef978a.jpg)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/快速排序.gif)

### （3）快速排序算法

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/fe814a70-8c66-4cb8-bbf7-b6306d3ffe88.png)

#### ① 整型数组版—不考虑稳定性

```java
package com.atguigu.array.sort;

/**
 * 快速排序
 * 通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分关键字小，
 * 则分别对这两部分继续进行排序，直到整个序列有序。
 * @author shkstart
 * 2018-12-17
 */
public class QuickSort {
    private static void swap(int[] data, int i, int j) {
        int temp = data[i];
        data[i] = data[j];
        data[j] = temp;
    }

    private static void subSort(int[] data, int start, int end) {
        if (start < end) {
            int base = data[start];
            int low = start;
            int high = end + 1;
            while (true) {
                while (low < end && data[++low] - base <= 0)
                    ;
                while (high > start && data[--high] - base >= 0)
                    ;
                if (low < high) {
                    swap(data, low, high);
                } else {
                    break;
                }
            }
            swap(data, start, high);
            
            subSort(data, start, high - 1);//递归调用
            subSort(data, high + 1, end);
        }
    }
    public static void quickSort(int[] data){
        subSort(data,0,data.length-1);
    }
    
    
    public static void main(String[] args) {
        int[] data = { 9, -16, 30, 23, -30, -49, 25, 21, 30 };
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        quickSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```

#### ② 对象数组版—考虑稳定性

```java
package com.atguigu.array.sort2;

/**
 * 快速排序
 * @author shkstart
 * 2018-12-17
 */
public class QuickSort {
    private static void swap(DataWrap[] data, int i, int j) {
        DataWrap temp = data[i];
        data[i] = data[j];
        data[j] = temp;
    }

    private static void subSort(DataWrap[] data, int start, int end) {
        if (start < end) {
            DataWrap base = data[start];
            int i = start;
            int j = end + 1;
            while (true) {
                while (i < end && data[++i].compareTo(base) <= 0)
                    ;
                while (j > start && data[--j].compareTo(base) >= 0)
                    ;
                if (i < j) {
                    swap(data, i, j);
                } else {
                    break;
                }
            }
            swap(data, start, j);
            subSort(data, start, j - 1);
            subSort(data, j + 1, end);
        }
    }
    public static void quickSort(DataWrap[] data){
        subSort(data,0,data.length-1);
    }
    public static void main(String[] args) {
        DataWrap[] data = { new DataWrap(9, ""), new DataWrap(-16, ""),
                new DataWrap(21, "*"), new DataWrap(23, ""),
                new DataWrap(-30, ""), new DataWrap(-49, ""),
                new DataWrap(21, ""), new DataWrap(30, "*"),
                new DataWrap(30, "") };
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        quickSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```



### （4）快速排序的效率分析

#### ① 快速排序的递归树

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/b9a5a54b-d7c4-412d-bfc9-2c44c1f31abf.jpg)

#### ② 快速排序的时间复杂度

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/95e3114b-caf2-4f91-8c4d-ab483cd1b2db.png)

#### ③ 快速排序的空间复杂度及稳定性

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/ef92d3b8-f182-4371-898a-2157ac5cc575.png)

# 四、选择排序

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/2bfb4186-ffac-49be-80e2-b32c9e818287.png)

## 1、简单选择排序

### （1）简单选择排序基本思想

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/a96e386e-ca47-40ae-85e5-fe2d65ba7833.jpg)

### （2）简单选择排序举例

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/bf518c71-b3d6-4091-af50-64385c416d52.jpg)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/(简单)选择排序.gif)

### （3）简单选择排序算法

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/7a6bfac2-8aab-45c8-87ad-3226430fc359.png)

#### ① 整型数组版—不考虑稳定性

```java
package com.atguigu.array.sort;


/**
 * 直接选择排序
 * @author shkstart
 * 2018-12-17
 */
public class SelectSort {
    public static void selectSort(int[] data) {
        System.out.println("开始排序");
        int arrayLength = data.length;
        for (int i = 0; i < arrayLength - 1; i++) {
            for (int j = i + 1; j < arrayLength; j++) {
                if (data[i] - data[j] > 0) {
                    int temp = data[i];
                    data[i] = data[j];
                    data[j] = temp;
                }
            }
            System.out.println(java.util.Arrays.toString(data));
        }
    }

    public static void main(String[] args) {
        int[] data = { 9, -16, 21, 23, -30, -49, 21, 30, 30 };
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        selectSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```



```java
package com.atguigu.array.sort;

/**
 * 直接选择排序-改进
 * @author shkstart
 * 2018-12-17
 */
public class SelectSort2 {
    public static void selectSort(int[] data) {
        System.out.println("开始排序");
        int arrayLength = data.length;
        for (int i = 0; i < arrayLength - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < arrayLength; j++) {
                if (data[minIndex] - data[j] > 0) {
                    minIndex = j;
                    
                }
            }
            if(minIndex != i){
                int temp = data[i];
                data[i] = data[minIndex];
                data[minIndex] = temp;
            }
            System.out.println(java.util.Arrays.toString(data));
        }
    }

    public static void main(String[] args) {
        int[] data = { 9, -16, 21, 23, -30, -49, 21, 30, 30 };
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        selectSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```



#### ② 对象数组版—考虑稳定性

```java
package com.atguigu.array.sort2;


/**
 * 直接选择排序
 * @author shkstart
 * 2018-12-17
 */
public class SelectSort {
    public static void selectSort(DataWrap[] data) {
        System.out.println("开始排序");
        int arrayLength = data.length;
        for (int i = 0; i < arrayLength - 1; i++) {
            for (int j = i + 1; j < arrayLength; j++) {
                if (data[i].compareTo(data[j]) > 0) {
                    DataWrap temp = data[i];
                    data[i] = data[j];
                    data[j] = temp;
                }
            }
            System.out.println(java.util.Arrays.toString(data));
        }
    }

    public static void main(String[] args) {
        DataWrap[] data = { new DataWrap(9, ""), new DataWrap(-16, ""),
                new DataWrap(21, "*"), new DataWrap(23, ""),
                new DataWrap(-30, ""), new DataWrap(-49, ""),
                new DataWrap(21, ""), new DataWrap(30, "*"),
                new DataWrap(30, "") };
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        selectSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```



```java
package com.atguigu.array.sort2;

/**
 * 直接选择排序-改进
 * @author shkstart
 * 2018-12-17
 */
public class SelectSort2 {
    public static void selectSort(DataWrap[] data) {
        System.out.println("开始排序");
        int arrayLength = data.length;
        for (int i = 0; i < arrayLength - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < arrayLength; j++) {
                if (data[minIndex].compareTo(data[j]) > 0) {
                    minIndex = j;
                    
                }
            }
            if(minIndex != i){
                DataWrap temp = data[i];
                data[i] = data[minIndex];
                data[minIndex] = temp;
            }
            System.out.println(java.util.Arrays.toString(data));
        }
    }

    public static void main(String[] args) {
        DataWrap[] data = { new DataWrap(9, ""), new DataWrap(-16, ""),
                new DataWrap(21, "*"), new DataWrap(23, ""),
                new DataWrap(-30, ""), new DataWrap(-49, ""),
                new DataWrap(21, ""), new DataWrap(30, "*"),
                new DataWrap(30, "") };
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        selectSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```



### （4）简单选择排序的效率分析

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/2a811a03-89ac-4d3c-bf17-a81382ae9689.jpg)

## 2、堆排序

### （1）选择排序-堆排序的引入

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/097f656c-48fb-4bf8-88b1-6bdb4d7d8e9c.png)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/f783c410-dab8-4b73-9bc8-87e1e6a90f5d.jpg)

### （2）堆的定义

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/c0e7e79b-9f40-4672-9086-467b9dba8610.jpg)

### （3）小顶堆和大顶堆示例

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/fd8457d0-a82d-44fe-9658-c7b8572ff72d.jpg)

### （4）堆排序的基本思想

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/a03f1061-29fe-4d5b-8751-b1ce702c2b98.jpg)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/448291aa-4ebc-4c40-8c57-170437a35587.jpg)

### （5）堆排序的关键问题

#### ① 如何由一个无序序列建成一个堆？

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/04b5ed2e-f1da-4161-8640-142ea4e7baec.png)

#### ② 如何在输出堆顶元素之后，调整剩余元素，使之成为一个新的堆？

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/e0e2670e-d763-4bdf-9ae2-d659b2eaa391.png)

### （6）堆排序举例(以大顶堆为例)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/8972877c-aee1-47e4-bcaf-d757380aef0a.jpg)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/390c5d1e-305f-4139-8fcd-65628c66a55e.jpg)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/堆排序.gif)

### （7）堆排序算法(以大顶堆为例)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/d36271e5-1ef6-450d-9a06-1d92ed66d610.jpg)

#### ① 整型数组版—不考虑稳定性

```java
package com.atguigu.array.sort;

/**
 * 堆排序
 * 
 * @author shkstart 2018-12-17
 */
public class HeapSort {
    public static void heapSort(int[] data) {
        System.out.println("开始排序");
        int arrayLength = data.length;
        // 循环建堆
        for (int i = 0; i < arrayLength - 1; i++) {
            // 建堆
            buildMaxdHeap(data, arrayLength - 1 - i);
            // 交换堆顶和最后一个元素
            swap(data, 0, arrayLength - 1 - i);
            System.out.println(java.util.Arrays.toString(data));
        }
    }

    // 对data数组从0到lastIndex建大顶堆
    private static void buildMaxdHeap(int[] data, int lastIndex) {
        // 从lastIndex处节点（最后一个节点）的父节点开始
        for (int i = (lastIndex - 1) / 2; i >= 0; i--) {
            // k保存当前正在判断的节点
            int k = i;
            // 如果当前k节点的子节点存在
            while (k * 2 + 1 <= lastIndex) {
                // k节点的左子节点的索引
                int biggerIndex = 2 * k + 1;
                // 如果biggerIndex小于lastIndex，即biggerIndex +1
                // 代表k节点的右子节点存在
                if (biggerIndex < lastIndex) {
                    // 如果右子节点的值较大
                    if (data[biggerIndex] - data[biggerIndex + 1] < 0) {
                        // biggerIndex总是记录较大子节点的索引
                        biggerIndex++;
                    }
                }
                // 如果k节点的值小于其较大子节点的值
                if (data[k] - data[biggerIndex] < 0) {
                    // 交换它们
                    swap(data, k, biggerIndex);
                    // 将biggerIndex赋给k，开始while循环的下一次循环
                    // 重新保证k节点的值大于其左、右节点的值
                    k = biggerIndex;
                } else {
                    break;
                }
            }
        }
    }

    // 交换data数组中i、j两个索引处的元素
    private static void swap(int[] data, int i, int j) {
        int temp = data[i];
        data[i] = data[j];
        data[j] = temp;
    }

    public static void main(String[] args) {
        int[] data = { 9, -16, 21, 23, -30, -49, 21, 30, 30 };
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        heapSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```



#### ② 对象数组版—考虑稳定性

```java
package com.atguigu.array.sort2;

/**
 * 堆排序
 * @author shkstart
 * 2018-12-17
 */
public class HeapSort {
    public static void heapSort(DataWrap[] data) {
        System.out.println("开始排序");
        int arrayLength = data.length;
        // 循环建堆
        for (int i = 0; i < arrayLength - 1; i++) {
            // 建堆
            builMaxdHeap(data, arrayLength - 1 - i);
            // 交换堆顶和最后一个元素
            swap(data, 0, arrayLength - 1 - i);
            System.out.println(java.util.Arrays.toString(data));
        }
    }

    // 对data数组从0到lastIndex建大顶堆
    private static void builMaxdHeap(DataWrap[] data, int lastIndex) {
        // 从lastIndex处节点（最后一个节点）的父节点开始
        for (int i = (lastIndex - 1) / 2; i >= 0; i--) {
            // k保存当前正在判断的节点
            int k = i;
            // 如果当前k节点的子节点存在
            while (k * 2 + 1 <= lastIndex) {
                // k节点的左子节点的索引
                int biggerIndex = 2 * k + 1;
                // 如果biggerIndex小于lastIndex，即biggerIndex +1
                // 代表k节点的右子节点存在
                if (biggerIndex < lastIndex) {
                    // 如果右子节点的值较大
                    if (data[biggerIndex].compareTo(data[biggerIndex + 1]) < 0) {
                        // biggerIndex总是记录较大子节点的索引
                        biggerIndex++;
                    }
                }
                // 如果k节点的值小于其较大子节点的值
                if (data[k].compareTo(data[biggerIndex]) < 0) {
                    // 交换它们
                    swap(data, k, biggerIndex);
                    // 将biggerIndex赋给k，开始while循环的下一次循环
                    // 重新保证k节点的值大于其左、右节点的值
                    k = biggerIndex;
                } else {
                    break;
                }
            }
        }
    }

    // 交换data数组中i、j两个索引处的元素
    private static void swap(DataWrap[] data, int i, int j) {
        DataWrap temp = data[i];
        data[i] = data[j];
        data[j] = temp;
    }

    public static void main(String[] args) {
        DataWrap[] data = { new DataWrap(9, ""), new DataWrap(-16, ""),
                new DataWrap(21, "*"), new DataWrap(23, ""),
                new DataWrap(-30, ""), new DataWrap(-49, ""),
                new DataWrap(21, ""), new DataWrap(30, "*"),
                new DataWrap(30, "")};
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        heapSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```

### （8）堆排序的效率分析

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/09929523-7265-4843-9d42-798871c953d3.jpg)

# 五、归并排序

## 1、二路归并排序

### （1）二路归并排序的基本思想

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/7daa7e8e-5534-4f34-837a-3a4abb3d1172.jpg)

### （2）二路归并排序举例

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/076e027b-38f8-4881-8c55-72ba9319c054.jpg)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/归并排序.gif)

### （3）二路归并排序算法

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/878f8e30-cba9-49eb-b364-0056e61b9b11.jpg)

#### ① 整型数组版—不考虑稳定性

```java
package com.atguigu.array.sort;

/**
 * 归并排序
 * 
 * @author shkstart 
 * 2018-12-17
 */
public class MergeSort {
    public static void mergeSort(int[] data) {
        // 归并排序
        sort(data, 0, data.length - 1);
    }

    // 将索引从left到right范围的数组元素进行归并排序
    private static void sort(int[] data, int left, int right) {
        if(left < right){
            //找出中间索引
            int center = (left + right)/2;
            sort(data,left,center);
            sort(data,center+1,right);
            //合并
            merge(data,left,center,right);
        }
    }

    // 将两个数组进行归并，归并前两个数组已经有序，归并后依然有序
    private static void merge(int[] data, int left, int center, int right) {
        int[] tempArr = new int[data.length];
        int mid = center + 1;
        int third = left;
        int temp = left;
        while (left <= center && mid <= right) {
            if (data[left] - data[mid] <= 0) {
                tempArr[third++] = data[left++];
            } else {
                tempArr[third++] = data[mid++];
            }
        }
        while (mid <= right) {
            tempArr[third++] = data[mid++];
        }
        while (left <= center) {
            tempArr[third++] = data[left++];
        }
        while (temp <= right) {
            data[temp] = tempArr[temp++];
        }
    }

    public static void main(String[] args) {
        int[] data = { 9, -16, 21, 23, -30, -49, 21, 30, 30 };
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        mergeSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```



#### ② 对象数组版—考虑稳定性

```java
package com.atguigu.array.sort2;

/**
 * 归并排序
 * 
 * @author shkstart 
 * 2018-12-17
 */
public class MergeSort {
    public static void mergeSort(DataWrap[] data) {
        // 归并排序
        sort(data, 0, data.length - 1);
    }

    // 将索引从left到right范围的数组元素进行归并排序
    private static void sort(DataWrap[] data, int left, int right) {
        if(left < right){
            //找出中间索引
            int center = (left + right)/2;
            sort(data,left,center);
            sort(data,center+1,right);
            //合并
            merge(data,left,center,right);
        }
    }

    // 将两个数组进行归并，归并前两个数组已经有序，归并后依然有序
    private static void merge(DataWrap[] data, int left, int center, int right) {
        DataWrap[] tempArr = new DataWrap[data.length];
        int mid = center + 1;
        int third = left;
        int temp = left;
        while (left <= center && mid <= right) {
            if (data[left].compareTo(data[mid]) <= 0) {
                tempArr[third++] = data[left++];
            } else {
                tempArr[third++] = data[mid++];
            }
        }
        while (mid <= right) {
            tempArr[third++] = data[mid++];
        }
        while (left <= center) {
            tempArr[third++] = data[left++];
        }
        while (temp <= right) {
            data[temp] = tempArr[temp++];
        }
    }

    public static void main(String[] args) {
        DataWrap[] data = { new DataWrap(9, ""), new DataWrap(-16, ""),
                new DataWrap(21, "*"), new DataWrap(23, ""),
                new DataWrap(-30, ""), new DataWrap(-49, ""),
                new DataWrap(21, ""), new DataWrap(30, "*"),
                new DataWrap(30, "") };
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        mergeSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```



### （4）二路归并排序的效率

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/b855ce99-5986-4508-8103-d2b08ed42611.png)

# 六、基数排序

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/728608d2-0a09-40ea-808f-2800bb95596e.png)

## 1、多关键字的排序

### （1）定义

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/ad8c9659-b0f1-4eb0-991b-ea509860bd4c.png)

### （2）实现多关键字排序的两种做法

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/11073a8a-e863-42ab-a410-839a472385bc.png)

### （3）举例

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/ec1be448-d373-4954-8b43-f58d53cf0cd4.png)

### （4）MSD法和LSD法的比较

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/58f7414b-36bd-4aa0-b23b-45df16436851.png)

## 2、链式基数排序

### （1）基本思想

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/ccde1b51-648d-45a9-946b-ee0d077d9ab6.png)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/1945ad64-3d79-4759-b06f-3b4deec26ff3.png)

### （2）举例

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/e286e7d6-0207-4021-906e-ccf686c89961.png)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/34deb8dd-801c-4727-a09c-5ec6599c9b90.jpg)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/基数排序.gif)

### （3）算法实现

#### ① 整型数组版—不考虑稳定性

```java
package com.atguigu.array.sort;

import java.util.Arrays;

/**
 * 基数排序
 * 
 * @author shkstart 2018-12-17
 */
public class MultiKeyRadixSort {
    public static void radixSort(int[] data, int radix, int d) {
        System.out.println("开始排序：");
        int arrayLength = data.length;
        int[] temp = new int[arrayLength];
        int[] buckets = new int[radix];
        for (int i = 0, rate = 1; i < d; i++) {
            // 重置count数组，开始统计第二个关键字
            Arrays.fill(buckets, 0);
            // 当data数组的元素复制到temp数组中进行缓存
            System.arraycopy(data, 0, temp, 0, arrayLength);
            for (int j = 0; j < arrayLength; j++) {
                int subKey = (temp[j] / rate) % radix;
                buckets[subKey]++;
            }
            for (int j = 1; j < radix; j++) {
                buckets[j] = buckets[j] + buckets[j - 1];
            }
            for (int m = arrayLength - 1; m >= 0; m--) {
                int subKey = (temp[m] / rate) % radix;
                data[--buckets[subKey]] = temp[m];
            }
            System.out.println("对" + rate + "位上子关键字排序："
                    + java.util.Arrays.toString(data));
            rate *= radix;
        }
    }

    public static void main(String[] args) {
        int[] data = { 1100, 192, 221, 12, 13 };
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        radixSort(data, 10, 4);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```



#### ② 对象数组版—考虑稳定性

```java
package com.atguigu.array.sort;

import java.util.Arrays;

/**
 * 基数排序
 * 
 * @author shkstart 2018-12-17
 */
public class MultiKeyRadixSort {
    public static void radixSort(DataWrap[] data, int radix, int d) {
        System.out.println("开始排序：");
        int arrayLength = data.length;
        DataWrap[] temp = new DataWrap[arrayLength];
        int[] buckets = new int[radix];
        for (int i = 0, rate = 1; i < d; i++) {
            // 重置count数组，开始统计第二个关键字
            Arrays.fill(buckets, 0);
            // 当data数组的元素复制到temp数组中进行缓存
            System.arraycopy(data, 0, temp, 0, arrayLength);
            for (int j = 0; j < arrayLength; j++) {
                int subKey = (temp[j].data / rate) % radix;
                buckets[subKey]++;
            }
            for (int j = 1; j < radix; j++) {
                buckets[j] = buckets[j] + buckets[j - 1];
            }
            for (int m = arrayLength - 1; m >= 0; m--) {
                int subKey = (temp[m].data / rate) % radix;
                data[--buckets[subKey]] = temp[m];
            }
            System.out.println("对" + rate + "位上子关键字排序："
                    + java.util.Arrays.toString(data));
            rate *= radix;
        }
    }

    public static void main(String[] args) {
        DataWrap[] data = { new DataWrap(1100, ""), new DataWrap(192, ""),
                new DataWrap(221, "*"), new DataWrap(12, ""),
                new DataWrap(13, "")};
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        radixSort(data, 10, 4);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```

### （4）效率分析

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/5bc209a6-6d36-475b-9e19-6ba7d0bd2e5f.png)

# 七、桶排序

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/桶排序.png)

## 1、整型数组版—不考虑稳定性

```java
package com.atguigu.array.sort;

import java.util.Arrays;

/**
 * 桶式排序
 * 
 * @author shkstart 2018-12-17
 */
public class BucketSort {
    public static void bucketSort(int[] data, int min, int max) {
        System.out.println("开始排序");
        int arrayLength = data.length;
        int[] temp = new int[arrayLength];
        int[] buckets = new int[max - min];
        for (int i = 0; i < arrayLength; i++) {
            buckets[data[i] - min]++;
        }
        System.out.println(Arrays.toString(buckets));
        for (int i = 1; i < max - min; i++) {
            buckets[i] = buckets[i] + buckets[i - 1];
        }
        System.out.println(Arrays.toString(buckets));
        System.arraycopy(data, 0, temp, 0, arrayLength);
        for (int k = arrayLength - 1; k >= 0; k--) {
            data[--buckets[temp[k] - min]] = temp[k];
        }
    }

    public static void main(String[] args) {
        int[] data = { 9, 5, -1, 8, 5, 7, 3, -3, 1, 3 };
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        bucketSort(data, -3, 10);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```



## 2、对象数组版—考虑稳定性

```java
package com.atguigu.array.sort2;

import java.util.Arrays;

/**
 * 桶式排序
 * 
 * @author shkstart 
 * 2018-12-17
 */
public class BucketSort {
    public static void bucketSort(DataWrap[] data, int min, int max) {
        System.out.println("开始排序");
        int arrayLength = data.length;
        DataWrap[] temp = new DataWrap[arrayLength];
        int[] buckets = new int[max - min];
        for (int i = 0; i < arrayLength; i++) {
            buckets[data[i].data - min]++;
        }
        System.out.println(Arrays.toString(buckets));
        for (int i = 1; i < max - min; i++) {
            buckets[i] = buckets[i] + buckets[i - 1];
        }
        System.out.println(Arrays.toString(buckets));
        System.arraycopy(data, 0, temp, 0, arrayLength);
        for (int k = arrayLength - 1; k >= 0; k--) {
            data[--buckets[temp[k].data - min]] = temp[k];
        }
    }

    public static void main(String[] args) {
        DataWrap[] data = { new DataWrap(9, ""), new DataWrap(5, ""),
                new DataWrap(-1, ""), new DataWrap(8, ""),
                new DataWrap(5, "*"), new DataWrap(7, ""),
                new DataWrap(3, ""), new DataWrap(-3, ""),
                new DataWrap(1, ""),new DataWrap(3, "*")};
        System.out.println("排序之前：\n" + java.util.Arrays.toString(data));
        bucketSort(data, -3, 10);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
    }
}

```







# 八、外排序简介

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/7fb20e57-587b-4df1-8404-11fefad3088a.jpg)

## 1、外存信息的存取-磁带

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/9999959e-af4b-4c58-9c74-5feed2850410.png)

## 2、外存信息的存取-磁盘

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/cbb2c7d3-d308-43fc-8a72-a63029598ab8.png)

## 3、外部排序的基本方法

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/ddc7ba1c-b546-40c0-94a4-43d22b97e59c.jpg)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/4761e4d1-e411-4379-a217-c2c1cb6f7fdf.png)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/5ce450ad-8fe7-43e9-b1b7-aff004867b21.png)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/6b28cbe1-4f0a-43f8-b52f-00bb797beb12.png)

# 九、各种内部排序的比较及选择

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/5340799c-db0d-43f8-8c99-fb41b4bfcda0.png)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/a8fe3ce9-3a51-42f6-b18c-dd3fe447ea36.jpg)

![img](file:///D:/Documents/My%20Knowledge/temp/c7d5d8dc-cbb1-4296-a030-8409309816cc/128/index_files/3b01d533-2dc8-47d9-a139-b22433627e7d.png)