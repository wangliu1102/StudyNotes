# 一、File类的使用 

## 1、File类的介绍

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/65fee7d4-8856-43e3-bd64-8ae789ad2b9b.png)

## 2、File类的常用构造器

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/a470212b-a2ab-4cc0-94fe-fffa11f5c404.png)

## 3、File类的路径分隔符

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/e46ecf44-8d31-453e-ac27-aac7d06e7bac.png)

## 4、File类的常用方法

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/b14789fc-dc4a-46bf-8825-f59ce4bacdf7.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/5029b57f-a5e2-4cb0-ba68-51037d5fe849.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/575b7827-9e9b-4297-8298-17edad9e4d45.png)

## 5、File类的使用举例

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/d92d5779-6706-44a5-b680-6f90ff4d6272.jpg)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/6d5db628-f3b2-4b71-b382-d73a579dda34.png)

# 二、IO流原理及流的分类

## 1、Java IO 原理

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/001b563b-805b-4a93-b818-6dcea48fdaee.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/71c1c1b2-61a0-4cf6-9d74-9cabaca5bd02.jpg)

## 2、流的分类

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/01495296-1e05-49d5-8d4d-0d6f1c6acc36.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/69fe6b0f-af6c-43ab-8dbd-fb0f41eb4913.png)

## 3、IO 流体系

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/536009f5-7532-4be0-83a1-e03bbfd8662e.jpg)

## 4、节点流和处理流

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/5e3bbcd9-eee3-4c8e-b237-68c1a5bb4bf0.jpg)

## 5、InputStream & Reader

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/341ba16e-6633-4677-931b-02914207ce34.png)

### （1）InputStream

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/fceab5b0-7800-4223-a828-8d493b35e695.png)

### （2）Reader

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/ba01cff2-2b37-4e1c-b096-3194bcfa0229.png)

## 6、OutputStream & Writer

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/d3bd00f6-61d1-4dc2-ae94-3845f80f36a5.png)

### （1）OutputStream 

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/4191c700-d673-45e3-b91b-dc6355e00f59.png)

### （2）Writer

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/ff3af3eb-7aa7-47cd-aab5-2330ccd48b69.png)

# 三、节点流(或文件流)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/64de1a4a-1086-4997-98f3-1963397d267c.png)

## 1、读取文件

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/8da9d5d9-b3ea-4e4e-9df4-98a9d1ee8f4a.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/4b1d61bf-5f61-48e2-adee-a34b672a659c.png)

##  

## 2、写入文件

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/e8407480-78f6-4976-84e0-2b8d2f76b010.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/dd4ecdcf-c610-40a8-8ff3-331a25163b2d.png)

##  

## 3、节点流( 或文件流) ：注意点

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/279f742b-c8f1-42f2-a847-32694881a240.png)

```java
   /*
    实现对图片的复制操作
     */
    @Test
    public void testFileInputOutputStream()  {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            //
            File srcFile = new File("爱情与友情.jpg");
            File destFile = new File("爱情与友情2.jpg");

            //
            fis = new FileInputStream(srcFile);
            fos = new FileOutputStream(destFile);

            //复制的过程
            byte[] buffer = new byte[5];
            int len;
            while((len = fis.read(buffer)) != -1){
                fos.write(buffer,0,len);
            }

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(fos != null){
                //
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(fis != null){
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
        }

    }
```



# 四、处理流-缓冲流

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/98ec5c1c-72ff-4317-a2ca-7e7349101c10.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/66e8c12e-06b6-44ac-9cc4-784e3be01e8d.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/bed5d522-cebb-4312-8c08-8c67285700ec.jpg)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/70b91f5a-b3e9-499e-9ef2-56524a294ebd.png)



# 五、处理流-转换流

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/abfec1cf-5e71-4442-9471-a2e9f80d848b.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/bed71b8d-fe14-4d14-addf-050e9abc2425.png)

## 1、InputStreamReader

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/c77a14db-9372-40b8-8dd2-86d4de129556.png)

## 2、OutputStreamWriter

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/13637c1f-556a-455f-a0f6-6bb02bd24529.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/402b957c-1f76-43af-85bb-0a61759625fb.png)

## 3、补充：字符编码

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/83f9c4ec-80ae-4501-86b8-b6bc5d5ed886.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/77cb4314-fa93-4bac-8a4c-abc679376a7d.jpg)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/f4a58354-7ab3-4cf7-812c-246aa1ba5bd1.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/30bbc9de-b002-448d-bc75-e813bfc4483c.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/922ca1dc-44e8-4894-880d-570d45dc7a81.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/0544a7bb-8fd2-4599-a6ad-049170ce9a6a.png)



# 六、处理流-标准输入、输出流 (了解)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/77195435-451d-4c89-bf0d-9162186d0ac7.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/bd2bea32-e659-4bc3-9384-a43f6d25596a.png)



# 七、处理流-打印流 (了解)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/67d1823f-c5d7-404f-9a06-d689782c6946.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/fe282b35-11fc-4786-9b9c-90467daf9e44.png)



# 八、处理流-数据流 (了解)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/7afb55d9-80e7-40ac-bcdd-5dbb0af4ba84.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/dc146896-aa72-49b9-93c5-485b41cb6bd1.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/0c3c4b51-e30c-4430-b90e-3b75a94bdbd4.png)



# 九、处理流-对象流

## 1、ObjectInputStream和OjbectOutputSteam

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/e7a3372f-1782-4b42-8524-9c8145f03a77.png)

## 2、对象的序列化

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/5537c056-c37c-48e7-b5ac-c7f71ab00e53.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/49c52f5d-a099-4d04-b851-4124ac8ee2b6.png)

## 3、使用对象流序列化对象

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/6666deea-38aa-4956-be17-2263568858ee.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/8825c1f7-1501-4382-92c1-c0656fd993b0.png)

```java
package com.atguigu.java;

import java.io.Serializable;

/**
 * Person需要满足如下的要求，方可序列化
 * 1.需要实现接口：Serializable
 * 2.当前类提供一个全局常量：serialVersionUID
 * 3.除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性
 *   也必须是可序列化的。（默认情况下，基本数据类型可序列化）
 *
 *
 * 补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量
 *
 *
 * @author shkstart
 * @create 2019 上午 10:38
 */
public class Person implements Serializable{

    public static final long serialVersionUID = 475463534532L;

    private String name;
    private int age;
    private int id;
    private Account acct;

    public Person(String name, int age, int id) {
        this.name = name;
        this.age = age;
        this.id = id;
    }

    public Person(String name, int age, int id, Account acct) {
        this.name = name;
        this.age = age;
        this.id = id;
        this.acct = acct;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", id=" + id +
                ", acct=" + acct +
                '}';
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Person(String name, int age) {

        this.name = name;
        this.age = age;
    }

    public Person() {

    }
}

class Account implements Serializable{
    public static final long serialVersionUID = 4754534532L;
    private double balance;

    @Override
    public String toString() {
        return "Account{" +
                "balance=" + balance +
                '}';
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public Account(double balance) {

        this.balance = balance;
    }
}
 
```

```java
/**
 * 对象流的使用
 * 1.ObjectInputStream 和 ObjectOutputStream
 * 2.作用：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。
 *
 * 3.要想一个java对象是可序列化的，需要满足相应的要求。见Person.java
 *
 * 4.序列化机制：
 * 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种
 * 二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。
 * 当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。

 *
 * @author shkstart
 * @create 2019 上午 10:27
 */
public class ObjectInputOutputStreamTest {

    /*
    序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去
    使用ObjectOutputStream实现
     */
    @Test
    public void testObjectOutputStream(){
        ObjectOutputStream oos = null;

        try {
            //1.
            oos = new ObjectOutputStream(new FileOutputStream("object.dat"));
            //2.
            oos.writeObject(new String("我爱北京天安门"));
            oos.flush();//刷新操作

            oos.writeObject(new Person("王铭",23));
            oos.flush();

            oos.writeObject(new Person("张学良",23,1001,new Account(5000)));
            oos.flush();

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(oos != null){
                //3.
                try {
                    oos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
        }

    }

    /*
    反序列化：将磁盘文件中的对象还原为内存中的一个java对象
    使用ObjectInputStream来实现
     */
    @Test
    public void testObjectInputStream(){
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(new FileInputStream("object.dat"));

            Object obj = ois.readObject();
            String str = (String) obj;

            Person p = (Person) ois.readObject();
            Person p1 = (Person) ois.readObject();

            System.out.println(str); // 我爱北京天安门
            System.out.println(p); // Person{name='null', age=0, id=0, acct=null}
            System.out.println(p1); // Person{name='null', age=0, id=1001, acct=Account{balance=5000.0}}
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            if(ois != null){
                try {
                    ois.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```



# 十、随机存取文件流

## 1、RandomAccessFile 类

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/6cc43e31-9fef-4a39-bd71-1f4aa24cf0f8.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/56139ca1-7671-4085-8faa-7d04c01a804f.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/963fcdd2-01c4-47ee-bd3d-0eab53216128.png)

## 2、举例

### （1）读取文件内容

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/ff04ee54-7301-4249-b058-55657cf19567.png)

```java
    @Test
    public void  test() throws IOException {
        RandomAccessFile raf = new RandomAccessFile("test.txt", "rw");
        raf.seek(5); // 设置下标从第五位开始
        byte [] b = new byte[1024];
        int off = 0;
        int len = 5;
        raf.read(b, off, len);
        String str = new String(b, 0, len);
        System.out.println(str);// 678
        raf.close();
    }
```



### （2）写入文件内容

```java
    @Test
    public void test2() throws IOException {

        RandomAccessFile raf1 = new RandomAccessFile("hello2.txt","rw");

        raf1.seek(3);//将指针调到角标为3的位置
        raf1.write("xyz".getBytes());//

        raf1.close();

    }

```

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/f9f18a75-4c76-443c-aa24-b7268a77be1a.png)

```java
    /*
    使用RandomAccessFile实现数据的插入效果
     */
    @Test
    public void test3() throws IOException {

        RandomAccessFile raf1 = new RandomAccessFile("hello.txt","rw");

        raf1.seek(50);//将指针调到角标为3的位置
        //保存指针3后面的所有数据到StringBuilder中
        StringBuilder builder = new StringBuilder((int) new File("hello.txt").length());
        byte[] buffer = new byte[20];
        int len;
        while((len = raf1.read(buffer)) != -1){
            builder.append(new String(buffer,0,len)) ;
        }
        //调回指针，写入“xyz”
        raf1.seek(50);
        raf1.write("123".getBytes());

        //将StringBuilder中的数据写入到文件中
        raf1.write(builder.toString().getBytes());

        raf1.close();

    }
```

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/aa52f00f-64d8-48ed-9916-82add611215f.png)

# 十一、NIO.2中Path、Paths、Files类的使用

## 1、Java NIO概述

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/b5cb147f-39ce-416e-bb1e-c191522320c8.png)

## 2、NIO. 2

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/2209d5b3-3680-4ded-a40e-3d1978de7d10.png)

## 3、Path 、Paths 和Files 核心API

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/e023735f-b0a0-4691-8369-635f34f31337.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/553d5cc3-02a9-425b-8589-d0644fd3c1b1.png)

## 4、Path接口

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/5ec92d8a-e521-475d-aa6d-8eec627b7f08.png) 

```java
    //如何使用Paths实例化Path
    @Test
    public void test1() {
        Path path1 = Paths.get("d:\\nio\\hello.txt");//new File(String filepath)

        Path path2 = Paths.get("d:\\", "nio\\hello.txt");//new File(String parent,String filename);

        System.out.println(path1);// d:\nio\hello.txt
        System.out.println(path2);// d:\nio\hello.txt

        Path path3 = Paths.get("d:\\", "nio");
        System.out.println(path3);// d:\nio
    }

    //Path中的常用方法
    @Test
    public void test2() {
        Path path1 = Paths.get("d:\\", "nio\\nio1\\nio2\\hello.txt");
        Path path2 = Paths.get("hello.txt");

//      String toString() ： 返回调用 Path 对象的字符串表示形式
        System.out.println(path1); // d:\nio\nio1\nio2\hello.txt

//      boolean startsWith(String path) : 判断是否以 path 路径开始
        System.out.println(path1.startsWith("d:\\nio"));// true
//      boolean endsWith(String path) : 判断是否以 path 路径结束
        System.out.println(path1.endsWith("hello.txt"));// true
//      boolean isAbsolute() : 判断是否是绝对路径
        System.out.println(path1.isAbsolute() + "~");// true~
        System.out.println(path2.isAbsolute() + "~");// false~
//      Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径
        System.out.println(path1.getParent());// d:\nio\nio1\nio2
        System.out.println(path2.getParent()); // null
//      Path getRoot() ：返回调用 Path 对象的根路径
        System.out.println(path1.getRoot());// d:\
        System.out.println(path2.getRoot());// null
//      Path getFileName() : 返回与调用 Path 对象关联的文件名
        System.out.println(path1.getFileName() + "~");// hello.txt~
        System.out.println(path2.getFileName() + "~");// hello.txt~
//      int getNameCount() : 返回Path 根目录后面元素的数量
//      Path getName(int idx) : 返回指定索引位置 idx 的路径名称
        for (int i = 0; i < path1.getNameCount(); i++) {
            System.out.println(path1.getName(i) + "*****");
            // nio*****
            // nio1*****
            // nio2*****
            // hello.txt*****
        }

//      Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象
        System.out.println(path1.toAbsolutePath());// d:\nio\nio1\nio2\hello.txt
        System.out.println(path2.toAbsolutePath());// E:\学习资料\尚硅谷全套\尚硅谷Java学科全套教程\1.尚硅谷全套JAVA教程--基础阶段\尚硅谷Java核心基础_2019年版---------重点\课件笔记源码资料\5_代码\第2部分：Java高级编程\JavaSenior\day10\hello.txt
//      Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象
        Path path3 = Paths.get("d:\\", "nio");
        Path path4 = Paths.get("nioo\\hi.txt");
        path3 = path3.resolve(path4);
        System.out.println(path3); // d:\nio\nioo\hi.txt

//      File toFile(): 将Path转化为File类的对象
        File file = path1.toFile();//Path--->File的转换

        Path newPath = file.toPath();//File--->Path的转换

    }
```



## 5、Files 类

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/daa2a0c8-868a-4b19-8540-e29d1062a170.png)

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/9e58c0be-5dbf-4cde-b4f8-b98b37911c52.png)

```java
/**
 * Files工具类的使用：操作文件或目录的工具类
 * @author shkstart
 * @create 2019 下午 2:44
 */
public class FilesTest {

    @Test
    public void test1() throws IOException{
        Path path1 = Paths.get("d:\\", "hello.txt");
        Path path2 = Paths.get("atguigu.txt");
        Path path22 = Paths.get("d:\\home","atguigu.txt");

//      Path copy(Path src, Path dest, CopyOption … how) : 文件的复制
        //要想复制成功，要求path1对应的物理上的文件存在。path1对应的文件没有要求。
        Files.copy(path1, path2, StandardCopyOption.REPLACE_EXISTING);

//      Path createDirectory(Path path, FileAttribute<?> … attr) : 创建一个目录
        //要想执行成功，要求path对应的物理上的文件目录不存在。一旦存在，抛出异常。
        Path path3 = Paths.get("d:\\nio\\nio1");
//      Files.createDirectory(path3);// 只能一级一级创建，d:\nio必须存在且nio1不存在才不会抛异常

//      Path createFile(Path path, FileAttribute<?> … arr) : 创建一个文件
        //要想执行成功，要求path对应的物理上的文件不存在。一旦存在，抛出异常。
        Path path4 = Paths.get("d:\\nio\\hi.txt");
//      Files.createFile(path4);

//      void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错
//      Files.delete(path4);

//      void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除.如果不存在，正常执行结束
        Files.deleteIfExists(path3);

//      Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置
        //要想执行成功，src对应的物理上的文件需要存在，dest对应的文件没有要求。
        Files.move(path1, path22, StandardCopyOption.ATOMIC_MOVE);

//      long size(Path path) : 返回 path 指定文件的大小
        long size = Files.size(path2);
        System.out.println(size); // 53

    }

    @Test
    public void test2() throws IOException{
        Path path1 = Paths.get("d:\\", "hello.txt");
        Path path2 = Paths.get("atguigu.txt");
//      boolean exists(Path path, LinkOption … opts) : 判断文件是否存在
        System.out.println(Files.exists(path2, LinkOption.NOFOLLOW_LINKS)); // true

//      boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录
        //不要求此path对应的物理文件存在。
        System.out.println(Files.isDirectory(path1, LinkOption.NOFOLLOW_LINKS)); // false

//      boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件

//      boolean isHidden(Path path) : 判断是否是隐藏文件
        //要求此path对应的物理上的文件需要存在。才可判断是否隐藏。否则，抛异常。
        System.out.println(Files.isHidden(path1)); // false

//      boolean isReadable(Path path) : 判断文件是否可读
        System.out.println(Files.isReadable(path1)); // true
//      boolean isWritable(Path path) : 判断文件是否可写
        System.out.println(Files.isWritable(path1)); // true
//      boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在
        System.out.println(Files.notExists(path1, LinkOption.NOFOLLOW_LINKS));// false
    }

    /**
     * StandardOpenOption.READ:表示对应的Channel是可读的。
     * StandardOpenOption.WRITE：表示对应的Channel是可写的。
     * StandardOpenOption.CREATE：如果要写出的文件不存在，则创建。如果存在，忽略
     * StandardOpenOption.CREATE_NEW：如果要写出的文件不存在，则创建。如果存在，抛异常
     *
     * @author shkstart 邮箱：shkstart@126.com
     * @throws IOException
     */
    @Test
    public void test3() throws IOException{
        Path path1 = Paths.get("d:\\", "hello.txt");

//      InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象
        InputStream inputStream = Files.newInputStream(path1, StandardOpenOption.READ);

//      OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象
        OutputStream outputStream = Files.newOutputStream(path1, StandardOpenOption.WRITE,StandardOpenOption.CREATE);


//      SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。
        SeekableByteChannel channel = Files.newByteChannel(path1, StandardOpenOption.READ,StandardOpenOption.WRITE,StandardOpenOption.CREATE);

//      DirectoryStream<Path>  newDirectoryStream(Path path) : 打开 path 指定的目录
        Path path2 = Paths.get("d:\\home\\upload");
        DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path2);
        Iterator<Path> iterator = directoryStream.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }


    }
}
```



# 十二、每日练习

## 1、谈谈你对java.io.Serializable 接口的理解，我们知道它用于序列化，是空方法接口，还有其它认识吗？

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/ecce60a8-bfc6-4135-b616-d342795a5182.png)

## 2、说明流的三种分类方式?

流向：输入流、输出流

数据单位：字节流、字符流

流的角色：节点流、处理流

## 3、字节流与字符流的区别与使用情境?

字节流：read(byte[] buffer) / read() ，wirter一样以字节为单位。 非文本文件

字符流：read(char[] cbuf) / read() ，wirter一样以字符为单位。文本文件

## 4、转换流是哪两个类，分别的作用是什么？请分别创建两个类的对象?

InputStreamReader:将输入的字节流转换为输入的字符流。 解码

OutputStreamWriter：将输出的字符流转换为输出的字节流。编码

InputStreamReader isr = new InputStreamReader(new FileInputStream(“a.txt”),”utf-8”);

OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(“b.txt”),”gbk”);

## 5、流的基本应用总结？

![img](file:///D:/Documents/My Knowledge/temp/f470ae37-1053-44e9-a266-28be83e95c23/128/index_files/771d1694-8f43-4d4b-b8a7-4333240adafa.png)

## 6、什么是java序列化，如何实现java序列化？

答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。

可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。

序列化是为了解决在对对象流进行读写操作时所引发的问题。

序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。

## 7、使用处理流的优势有哪些？如何识别所使用的流是处理流还是节点流？

【答案】

【优势】对开发人员来说，使用处理流进行输入/输出操作更简单；使用处理流的执行效率更高。

【判别】

处理流的构造器的参数不是一个物理节点，而是已经存在的流。而节点流都是直接以物理IO及节点作为构造器参数的。

## 8、Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请指出它们分别是哪些类？

【答案】Java中按所操作的数据单元的不同，分为字节流和字符流。

字节流继承于InputStream和OutputStream类;

字符流继承于Reader和Writer。

按流的流向的不同，分为输入流和输出流。

按流的角色来分，可分为节点流和处理流。缓冲流、转换流、对象流和打印流等都属于处理流，使得输入/输出更简单，执行效率更高。

## 9、什么是标准的I/O流？

在java语言中，用stdin表示键盘，用stdout表示监视器。他们均被封装在System类的类变量in 和out中，对应于系统调用System.in和System.out。这样的两个流加上System.err统称为标准流，它们是在System类中声明的3个类变量：

public static InputStream in

public static PrintStream out

public static PrintStream err

## 10、数组有没有length()方法？String有没有length()方法？File有没有length()方法？ArrayList有没有length()方法？

数组没有length()方法，但是有length属性。

String和File有length()方法。

ArrayList没有length()方法，有size()方法获取有效元素个数。